<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fast Randomized Iteration for Electronic Structure: /home/travis/build/sgreene8/FRIES/FRIES/compress_utils.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fast Randomized Iteration for Electronic Structure
   </div>
   <div id="projectbrief">An implementation of FRI methods for quantum chemistry</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_607347b14e208e050cf2976c6f5bb11f.html">FRIES</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">compress_utils.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utilities for compressing vectors stochastically using the FRI framework.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="compress__utils_8hpp_source.html">compress_utils.hpp</a>&quot;</code><br />
<code>#include &lt;cstdio&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;climits&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;<a class="el" href="det__store_8h_source.html">FRIES/det_store.h</a>&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a76e52781f25a5e2197f1c9ce6722431e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#a76e52781f25a5e2197f1c9ce6722431e">round_binomially</a> (double p, unsigned int n, std::mt19937 &amp;mt_obj)</td></tr>
<tr class="memdesc:a76e52781f25a5e2197f1c9ce6722431e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a non-integral number binomially.  <a href="#a76e52781f25a5e2197f1c9ce6722431e">More...</a><br /></td></tr>
<tr class="separator:a76e52781f25a5e2197f1c9ce6722431e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942f5c8e5ed68adbf5b79a4a27ce883f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#a942f5c8e5ed68adbf5b79a4a27ce883f">find_preserve</a> (double *values, std::vector&lt; size_t &gt; &amp;srt_idx, std::vector&lt; bool &gt; &amp;keep_idx, size_t count, unsigned int *n_samp, double *global_norm)</td></tr>
<tr class="memdesc:a942f5c8e5ed68adbf5b79a4a27ce883f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the greatest-magnitude elements of a vector.  <a href="#a942f5c8e5ed68adbf5b79a4a27ce883f">More...</a><br /></td></tr>
<tr class="separator:a942f5c8e5ed68adbf5b79a4a27ce883f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbd13c575f5d56f4dbf0a510dbad157"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#aefbd13c575f5d56f4dbf0a510dbad157">seed_sys</a> (double *norms, double *rn, unsigned int n_samp)</td></tr>
<tr class="memdesc:aefbd13c575f5d56f4dbf0a510dbad157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set-up for performing systematic compression across many MPI processes.  <a href="#aefbd13c575f5d56f4dbf0a510dbad157">More...</a><br /></td></tr>
<tr class="separator:aefbd13c575f5d56f4dbf0a510dbad157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cf02db084b352f53d7912bd081500a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#a34cf02db084b352f53d7912bd081500a">find_keep_sub</a> (double *values, uint32_t *n_div, const <a class="el" href="class_matrix.html">Matrix</a>&lt; double &gt; &amp;sub_weights, <a class="el" href="class_matrix.html">Matrix</a>&lt; bool &gt; &amp;keep_idx, uint16_t *sub_sizes, size_t count, unsigned int *n_samp, double *wt_remain)</td></tr>
<tr class="memdesc:a34cf02db084b352f53d7912bd081500a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify elements to preserve exactly according to the FRI rule when vector elements are subdivided into sub-weights.  <a href="#a34cf02db084b352f53d7912bd081500a">More...</a><br /></td></tr>
<tr class="separator:a34cf02db084b352f53d7912bd081500a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e39e3bbbe19737bc2bc2046b526fbcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#a6e39e3bbbe19737bc2bc2046b526fbcf">sys_comp</a> (double *vec_vals, size_t vec_len, double *loc_norms, unsigned int n_samp, std::vector&lt; bool &gt; &amp;keep_exact, double rand_num)</td></tr>
<tr class="memdesc:a6e39e3bbbe19737bc2bc2046b526fbcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Systematic resampling of vector elements.  <a href="#a6e39e3bbbe19737bc2bc2046b526fbcf">More...</a><br /></td></tr>
<tr class="separator:a6e39e3bbbe19737bc2bc2046b526fbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a19c8e31b0c4f283926ec3cc083048"><td class="memItemLeft" align="right" valign="top"><a id="ac8a19c8e31b0c4f283926ec3cc083048"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sys_comp</b> (double *vec_vals, size_t vec_len, double *loc_norms, unsigned int n_samp, std::vector&lt; bool &gt; &amp;keep_exact, double rand_num, MPI_Comm comm)</td></tr>
<tr class="separator:ac8a19c8e31b0c4f283926ec3cc083048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76be40eac171eb464e31b4c3d797823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#ac76be40eac171eb464e31b4c3d797823">sys_comp_serial</a> (double *vec_vals, size_t vec_len, double seg_norm, double sampl_val, uint32_t n_samp, std::vector&lt; bool &gt; &amp;keep_exact, double rand_num)</td></tr>
<tr class="memdesc:ac76be40eac171eb464e31b4c3d797823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Systematic resampling of vector elements only on this process. Does not use MPI.  <a href="#ac76be40eac171eb464e31b4c3d797823">More...</a><br /></td></tr>
<tr class="separator:ac76be40eac171eb464e31b4c3d797823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0eced6e223d819b11bef4e80337733"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#a4f0eced6e223d819b11bef4e80337733">piv_comp_parallel</a> (double *vec_vals, size_t vec_len, uint32_t compress_size, std::vector&lt; size_t &gt; &amp;srt_scratch, std::vector&lt; bool &gt; &amp;keep_scratch, std::mt19937 &amp;rn_gen)</td></tr>
<tr class="memdesc:a4f0eced6e223d819b11bef4e80337733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel budgeting + pivotal compression of vector elements on all processes.  <a href="#a4f0eced6e223d819b11bef4e80337733">More...</a><br /></td></tr>
<tr class="separator:a4f0eced6e223d819b11bef4e80337733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a84e90413e0551354312b9af5be4688"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#a6a84e90413e0551354312b9af5be4688">piv_samp_serial</a> (double *vec_vals, size_t vec_len, double seg_norm, uint32_t n_samp, std::vector&lt; bool &gt; &amp;keep_exact, std::mt19937 &amp;mt_obj)</td></tr>
<tr class="memdesc:a6a84e90413e0551354312b9af5be4688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pivotal resampling of vector elements only on this process. Does not use MPI.  <a href="#a6a84e90413e0551354312b9af5be4688">More...</a><br /></td></tr>
<tr class="separator:a6a84e90413e0551354312b9af5be4688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036d17e49de9e2fa4561d535cbd56345"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#a036d17e49de9e2fa4561d535cbd56345">sys_budget</a> (double *loc_norms, uint32_t n_samp, double rand_num)</td></tr>
<tr class="memdesc:a036d17e49de9e2fa4561d535cbd56345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a budget for compressing vectors on each MPI process independently using systematic resampling.  <a href="#a036d17e49de9e2fa4561d535cbd56345">More...</a><br /></td></tr>
<tr class="separator:a036d17e49de9e2fa4561d535cbd56345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0907d1f92ff6b1c98d763ec8877c6fe7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#a0907d1f92ff6b1c98d763ec8877c6fe7">piv_budget</a> (double *loc_norms, uint32_t n_samp, std::mt19937 &amp;mt_obj)</td></tr>
<tr class="memdesc:a0907d1f92ff6b1c98d763ec8877c6fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a budget for compressing vectors on each MPI process independently using pivotal resampling.  <a href="#a0907d1f92ff6b1c98d763ec8877c6fe7">More...</a><br /></td></tr>
<tr class="separator:a0907d1f92ff6b1c98d763ec8877c6fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27fe5920aa6c97d86eecbdc3f8b3b0b"><td class="memItemLeft" align="right" valign="top"><a id="aa27fe5920aa6c97d86eecbdc3f8b3b0b"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>piv_budget</b> (double *loc_norms, uint32_t n_samp, std::mt19937 &amp;mt_obj, MPI_Comm comm)</td></tr>
<tr class="separator:aa27fe5920aa6c97d86eecbdc3f8b3b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51832c2e98de7f397d5a2f94bca00ed9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#a51832c2e98de7f397d5a2f94bca00ed9">adjust_probs</a> (double *vec_vals, size_t vec_len, uint32_t *n_samp_loc, double exp_nsamp_loc, uint32_t n_samp_tot, double tot_norm, std::vector&lt; bool &gt; &amp;keep_exact)</td></tr>
<tr class="memdesc:a51832c2e98de7f397d5a2f94bca00ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">If needed, adjust elements in a vector prior to resampling to ensure that each element can be selected only 0 or 1 times.  <a href="#a51832c2e98de7f397d5a2f94bca00ed9">More...</a><br /></td></tr>
<tr class="separator:a51832c2e98de7f397d5a2f94bca00ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e5ff484f0f1af4dce9091452ba37fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#ab2e5ff484f0f1af4dce9091452ba37fb">adjust_shift</a> (double *shift, double one_norm, double *last_norm, double target_norm, double damp_factor)</td></tr>
<tr class="memdesc:ab2e5ff484f0f1af4dce9091452ba37fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust energy shift to maintain one-norm of solution vector in DMC simulation.  <a href="#ab2e5ff484f0f1af4dce9091452ba37fb">More...</a><br /></td></tr>
<tr class="separator:ab2e5ff484f0f1af4dce9091452ba37fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af316eed20fb7d575122b8041065e9bdf"><td class="memItemLeft" align="right" valign="top"><a id="af316eed20fb7d575122b8041065e9bdf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_shift2</b> (double *shift, double one_norm, double *last_norm, double damp_factor)</td></tr>
<tr class="separator:af316eed20fb7d575122b8041065e9bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f29e7cccc4d84c3339d00898ff7c2fd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#a6f29e7cccc4d84c3339d00898ff7c2fd">sys_sub</a> (double *values, unsigned int *n_div, const <a class="el" href="class_matrix.html">Matrix</a>&lt; double &gt; &amp;sub_weights, <a class="el" href="class_matrix.html">Matrix</a>&lt; bool &gt; &amp;keep_idx, uint16_t *sub_sizes, size_t count, unsigned int n_samp, double *wt_remain, double *loc_norms, double rand_num, double *new_vals, size_t new_idx[][2])</td></tr>
<tr class="memdesc:a6f29e7cccc4d84c3339d00898ff7c2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform systematic resampling on a vector with subdivided elements.  <a href="#a6f29e7cccc4d84c3339d00898ff7c2fd">More...</a><br /></td></tr>
<tr class="separator:a6f29e7cccc4d84c3339d00898ff7c2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3147117505d81601c72d49d6de0df8e4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#a3147117505d81601c72d49d6de0df8e4">comp_sub</a> (double *values, size_t count, unsigned int *n_div, <a class="el" href="class_matrix.html">Matrix</a>&lt; double &gt; &amp;sub_weights, <a class="el" href="class_matrix.html">Matrix</a>&lt; bool &gt; &amp;keep_idx, uint16_t *sub_sizes, unsigned int n_samp, double *wt_remain, double rand_num, double *new_vals, size_t new_idx[][2])</td></tr>
<tr class="memdesc:a3147117505d81601c72d49d6de0df8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform systematic compression with exact preservation on a vector whose elements are divided into sub-weights.  <a href="#a3147117505d81601c72d49d6de0df8e4">More...</a><br /></td></tr>
<tr class="separator:a3147117505d81601c72d49d6de0df8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85d6f34bf95befdedb1c826ed0a58ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#ae85d6f34bf95befdedb1c826ed0a58ac">setup_alias</a> (double *probs, unsigned int *aliases, double *alias_probs, size_t n_states)</td></tr>
<tr class="memdesc:ae85d6f34bf95befdedb1c826ed0a58ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set-up for the alias method for multinomial sampling.  <a href="#ae85d6f34bf95befdedb1c826ed0a58ac">More...</a><br /></td></tr>
<tr class="separator:ae85d6f34bf95befdedb1c826ed0a58ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704ee5c402295a7caf02565175734a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#a704ee5c402295a7caf02565175734a47">sample_alias</a> (unsigned int *aliases, double *alias_probs, size_t n_states, uint8_t *samples, unsigned int n_samp, size_t samp_int, std::mt19937 &amp;mt_obj)</td></tr>
<tr class="memdesc:a704ee5c402295a7caf02565175734a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform multinomial sampling using the alias method.  <a href="#a704ee5c402295a7caf02565175734a47">More...</a><br /></td></tr>
<tr class="separator:a704ee5c402295a7caf02565175734a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70887dcde134f225bd19ed60d86ecb63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8cpp.html#a70887dcde134f225bd19ed60d86ecb63">sample_alias</a> (unsigned int *aliases, double *alias_probs, size_t n_states, uint16_t *counts, unsigned int n_samp, std::mt19937 &amp;mt_obj)</td></tr>
<tr class="memdesc:a70887dcde134f225bd19ed60d86ecb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform multinomial sampling using the alias method.  <a href="#a70887dcde134f225bd19ed60d86ecb63">More...</a><br /></td></tr>
<tr class="separator:a70887dcde134f225bd19ed60d86ecb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utilities for compressing vectors stochastically using the FRI framework. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a51832c2e98de7f397d5a2f94bca00ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51832c2e98de7f397d5a2f94bca00ed9">&#9670;&nbsp;</a></span>adjust_probs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double adjust_probs </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vec_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vec_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>n_samp_loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>exp_nsamp_loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n_samp_tot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tot_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>keep_exact</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If needed, adjust elements in a vector prior to resampling to ensure that each element can be selected only 0 or 1 times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vec_vals</td><td>Elements in the vector (can be negative) to be compressed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vec_len</td><td>Number of elements in this segment of the vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">n_samp_loc</td><td>The number of elements to be selected from this segment only </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exp_nsamp_loc</td><td>The expected value of <code>n_samp_loc</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_samp_tot</td><td>The total number of elements that will be selected from all segments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tot_norm</td><td>The total one-norm of all vector segmemts </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keep_exact</td><td>Array indicating elements to be preserved exactly in compression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One-norm of the segment after adjusting the probabilities </dd></dl>

</div>
</div>
<a id="ab2e5ff484f0f1af4dce9091452ba37fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e5ff484f0f1af4dce9091452ba37fb">&#9670;&nbsp;</a></span>adjust_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void adjust_shift </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>one_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>last_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>damp_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust energy shift to maintain one-norm of solution vector in DMC simulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">shift</td><td>Pointer to energy shift; updated upon return </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">one_norm</td><td>Current one-norm of solution vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">last_norm</td><td>Ptr to previous one-norm of solution vector, or 0 if vector norm is not yet being updated. Upon return, set to <code>one_norm</code> if one_norm &gt; target_norm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_norm</td><td>One-norm above which the energy shift should be adjusted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">damp_factor</td><td>Factor by which the shift calculated based on the change in one-norm is damped (or amplified) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3147117505d81601c72d49d6de0df8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3147117505d81601c72d49d6de0df8e4">&#9670;&nbsp;</a></span>comp_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t comp_sub </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>n_div</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a>&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>keep_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>sub_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wt_remain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rand_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>new_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_idx</em>[][2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform systematic compression with exact preservation on a vector whose elements are divided into sub-weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Magnitudes of elements of original vector on which to perform compression (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of vector to compress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_div</td><td>Number of uniform intervals into which each element is divided. If =0, this element is divided nonuniformly according to <code>sub_weights</code> at this position (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_weights</td><td>2-d array of sub-weights for vector elements divided nonuniformly; each nonzero row must sum to 1. Elements in rows corresponding to nonzero elements of n_div are undefined. (dimensions <code>count</code> * <code>n_sub</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_idx</td><td>Scratch array used to identify elements to preserve exactly. Must be 0 upon input (dimensions <code>count</code> * <code>n_sub</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_sizes</td><td>If non-null, sub_weights is treated as a jagged 2-D array, with <code>sub_sizes</code> denoting the number of elements in each row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_samp</td><td>Desired number of nonzero elements in compressed vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wt_remain</td><td>Scratch array used for compression (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rand_num</td><td>A random number chosen uniformly on [0, 1). Only the argument from the 0th MPI process is used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_vals</td><td>Magnitudes of elements in compressed vector, including elements preserved exactly </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_idx</td><td>Indices of elements of the compressed vector in the original (input) vector. The 0th column gives the index in the values array, and the 1st gives the index of the subdivided element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the compressed array (at most n_samp) </dd></dl>

</div>
</div>
<a id="a34cf02db084b352f53d7912bd081500a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34cf02db084b352f53d7912bd081500a">&#9670;&nbsp;</a></span>find_keep_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double find_keep_sub </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>n_div</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a>&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>keep_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>sub_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wt_remain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify elements to preserve exactly according to the FRI rule when vector elements are subdivided into sub-weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Magnitudes of elements of vector to be compressed (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_div</td><td>Number of uniform intervals into which each element is divided. If =0, this element is divided nonuniformly according to sub_wts at this position (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_weights</td><td>2-d array of sub-weights for vector elements divided nonuniformly; each nonzero row must sum to 1. Elements in rows corresponding to nonzero elements of n_div are undefined. (dimensions <code>count</code> x <code>n_sub</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">keep_idx</td><td>2-d array that contains 1's at all positions to be preserved exactly. Elements must be zeroed before calling. If vector is divided uniformly, only the element in the 0th column is set to 1 (dimensions <code>count</code> * <code>n_sub</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_sizes</td><td>If non-null, sub_weights is treated as a jagged 2-D array, with <code>sub_sizes</code> denoting the number of elements in each row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of vector to compress </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">n_samp</td><td>Pointer to desired number of nonzero elements after compression; upon return, points to remaining number available for systematic resampling </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">wt_remain</td><td>Sum of magnitudes of sub-elements not preserved exactly at each position (length <code>count</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of magnitudes of elements on this local MPI process that are not preserved exactly </dd></dl>

</div>
</div>
<a id="a942f5c8e5ed68adbf5b79a4a27ce883f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942f5c8e5ed68adbf5b79a4a27ce883f">&#9670;&nbsp;</a></span>find_preserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double find_preserve </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>srt_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>keep_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>global_norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify the greatest-magnitude elements of a vector. </p>
<p>The greatest-magnitude elements of the vector are identified according to the rule in the FRI paper and preserved exactly in the compression</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Vector of elements (can be + or -); not modified in this subroutine (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srt_idx</td><td>An array of indices that will be used to build the heap, must be initialized with integers from 0 to count - 1 in any order (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">keep_idx</td><td>Contains 1's at each position of values designated to be preserved exactly. Upon input, all elements must be 0 (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements in the vector being compressed </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">n_samp</td><td>Pointer to desired number of nonzero elements after compression. Upon return, points to remaining number available for systematic resampling </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">global_norm</td><td>The norm of the whole vector, including preserved elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of magnitudes of elements that are not preserved exactly </dd></dl>

</div>
</div>
<a id="a0907d1f92ff6b1c98d763ec8877c6fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0907d1f92ff6b1c98d763ec8877c6fe7">&#9670;&nbsp;</a></span>piv_budget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t piv_budget </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>loc_norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>mt_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a budget for compressing vectors on each MPI process independently using pivotal resampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">loc_norms</td><td>Sum of magnitudes of elements on each MPI process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_samp</td><td>Total number of elements (across all processes) to select in sampling </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mt_obj</td><td>A reference to an initialized MT object to use for random number generation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements to sample on this process </dd></dl>

</div>
</div>
<a id="a4f0eced6e223d819b11bef4e80337733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f0eced6e223d819b11bef4e80337733">&#9670;&nbsp;</a></span>piv_comp_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void piv_comp_parallel </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vec_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vec_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compress_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>srt_scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>keep_scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>rn_gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parallel budgeting + pivotal compression of vector elements on all processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vec_vals</td><td>Elements in the vector (can be negative) before and after compression (length <code>vec_len</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vec_len</td><td>Number of elements in the vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compress_size</td><td>Desired number of nonzero elements after compression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srt_scratch</td><td>An array of indices that will be used to build the heap, must be initialized with integers from 0 to count - 1 in any order (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keep_scratch</td><td>Upon input, all elements must be 0 (length <code>count</code>); upon return, 1's indicate elements zeroed in the compression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rn_gen</td><td>A reference to an initialized MT object to use for random number generation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a84e90413e0551354312b9af5be4688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a84e90413e0551354312b9af5be4688">&#9670;&nbsp;</a></span>piv_samp_serial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void piv_samp_serial </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vec_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vec_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seg_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>keep_exact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>mt_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pivotal resampling of vector elements only on this process. Does not use MPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vec_vals</td><td>Elements in the vector (can be negative) before and after compression (length <code>vec_len</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vec_len</td><td>Number of elements in the vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seg_norm</td><td>Sum of magnitudes of elements in this segment not preserved exactly </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_samp</td><td>Number of samples in pivotal resampling (just for this segment) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keep_exact</td><td>Array indicating elements to be preserved exactly in compression; upon return, 1's indicate elements zeroed in the compression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mt_obj</td><td>A reference to an initialized MT object to use for random number generation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76e52781f25a5e2197f1c9ce6722431e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e52781f25a5e2197f1c9ce6722431e">&#9670;&nbsp;</a></span>round_binomially()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int round_binomially </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>mt_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round a non-integral number binomially. </p>
<p>Given a non-integral input p and a positive-integral input n, the result r of this operation is distributed according to: </p><p class="formulaDsp">
\[ r \sim \text{binomial}(n, p - \text{floor}(p)) + \text{floor}(p) * n \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The non-integral parameter p of the rounding operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The positive integral parameter n of the rounding oper. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mt_obj</td><td>Reference to initialized MT object to use for RN generation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer result r of the operation </dd></dl>

</div>
</div>
<a id="a704ee5c402295a7caf02565175734a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704ee5c402295a7caf02565175734a47">&#9670;&nbsp;</a></span>sample_alias() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sample_alias </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>aliases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alias_probs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samp_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>mt_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform multinomial sampling using the alias method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aliases</td><td>Alias for each state, calculated using <a class="el" href="compress__utils_8hpp.html#ae85d6f34bf95befdedb1c826ed0a58ac" title="Set-up for the alias method for multinomial sampling. ">setup_alias()</a> (length <code>n_states</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alias_probs</td><td>Alias probabilities for each state, calculated using <a class="el" href="compress__utils_8hpp.html#ae85d6f34bf95befdedb1c826ed0a58ac" title="Set-up for the alias method for multinomial sampling. ">setup_alias()</a>; need not be initialized (length <code>n_states</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_states</td><td>Number of states that can be sampled </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">samples</td><td>The sampled indices, stored at intervals of <code>samp_int</code> (length <code>n_samp</code> * samp_int) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_samp</td><td>Number of samples to draw multinomially </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samp_int</td><td>The interval at which to save samples in the samples array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mt_obj</td><td>Reference to initialized MT object to use for RN generation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70887dcde134f225bd19ed60d86ecb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70887dcde134f225bd19ed60d86ecb63">&#9670;&nbsp;</a></span>sample_alias() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sample_alias </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>aliases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alias_probs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>mt_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform multinomial sampling using the alias method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aliases</td><td>Alias for each state, calculated using <a class="el" href="compress__utils_8hpp.html#ae85d6f34bf95befdedb1c826ed0a58ac" title="Set-up for the alias method for multinomial sampling. ">setup_alias()</a> (length <code>n_states</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alias_probs</td><td>Alias probabilities for each state, calculated using <a class="el" href="compress__utils_8hpp.html#ae85d6f34bf95befdedb1c826ed0a58ac" title="Set-up for the alias method for multinomial sampling. ">setup_alias()</a>; need not be initialized (length <code>n_states</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_states</td><td>Number of states that can be sampled </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counts</td><td>The number of samples at each index position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_samp</td><td>Number of samples to draw multinomially </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mt_obj</td><td>Reference to initialized MT object to use for RN generation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefbd13c575f5d56f4dbf0a510dbad157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbd13c575f5d56f4dbf0a510dbad157">&#9670;&nbsp;</a></span>seed_sys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double seed_sys </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_samp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set-up for performing systematic compression across many MPI processes. </p>
<p>Calculates the position of the first random sample on each MPI process</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">norms</td><td>Array of one-norms of the portions of the vector stored on each processor (length <code>n_samp</code>) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rn</td><td>Pointer to a random number generated on [0,1). Upon return, will be set to the position of the random sample (the "X" in the paper) within this portion of the vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_samp</td><td>Desired number of elements to select randomly </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of the one-norms of the portions of the vector stored on MPI processes with ranks less than the current one </dd></dl>

</div>
</div>
<a id="ae85d6f34bf95befdedb1c826ed0a58ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85d6f34bf95befdedb1c826ed0a58ac">&#9670;&nbsp;</a></span>setup_alias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setup_alias </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>probs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>aliases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alias_probs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set-up for the alias method for multinomial sampling. </p>
<p>Calculates the alias for each state and the alternative probabilities according to the algorithm in Figure 4 of Holmes et al. (2016)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">probs</td><td>Normalized probabilities of choosing each state (length <code>n_states</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aliases</td><td>Alias for each state (length <code>n_states</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">alias_probs</td><td>The probability of choosing the state i instead of its alias aliases[i] (length <code>n_states</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_states</td><td>The number of states </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a036d17e49de9e2fa4561d535cbd56345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036d17e49de9e2fa4561d535cbd56345">&#9670;&nbsp;</a></span>sys_budget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_budget </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>loc_norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rand_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a budget for compressing vectors on each MPI process independently using systematic resampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">loc_norms</td><td>Sum of magnitudes of elements on each MPI process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_samp</td><td>Total number of elements (across all processes) to select in sampling </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rand_num</td><td>A random number chosen uniformly on [0, 1). Only the argument from the 0th MPI process is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements to sample on this process </dd></dl>

</div>
</div>
<a id="a6e39e3bbbe19737bc2bc2046b526fbcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e39e3bbbe19737bc2bc2046b526fbcf">&#9670;&nbsp;</a></span>sys_comp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_comp </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vec_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vec_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>loc_norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>keep_exact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rand_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Systematic resampling of vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vec_vals</td><td>Elements in the vector (can be negative) before and after compression (length <code>vec_len</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vec_len</td><td>Number of elements in the vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">loc_norms</td><td>Sum of magnitudes of elements on each MPI process before and after compression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_samp</td><td>Number of samples in systematic resampling </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keep_exact</td><td>Array indicating elements to be preserved exactly in compression; upon return, 1's indicate elements zeroed in the compression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rand_num</td><td>A random number chosen uniformly on [0, 1). Only the argument from the 0th MPI process is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac76be40eac171eb464e31b4c3d797823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76be40eac171eb464e31b4c3d797823">&#9670;&nbsp;</a></span>sys_comp_serial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_comp_serial </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vec_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vec_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seg_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampl_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>keep_exact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rand_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Systematic resampling of vector elements only on this process. Does not use MPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vec_vals</td><td>Elements in the vector (can be negative) before and after compression (length <code>vec_len</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vec_len</td><td>Number of elements in the vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seg_norm</td><td>Sum of magnitudes of elements in this segment not preserved exactly </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampl_val</td><td>Magnitude to assign to elements selected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_samp</td><td>Number of samples in systematic resampling (just for this segment) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keep_exact</td><td>Array indicating elements to be preserved exactly in compression; upon return, 1's indicate elements zeroed in the compression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rand_num</td><td>A random number chosen uniformly on [0, 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f29e7cccc4d84c3339d00898ff7c2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f29e7cccc4d84c3339d00898ff7c2fd">&#9670;&nbsp;</a></span>sys_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sys_sub </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>n_div</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a>&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>keep_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>sub_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wt_remain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>loc_norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rand_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>new_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_idx</em>[][2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform systematic resampling on a vector with subdivided elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Magnitudes of elements of original vector to be compressed, potentially with some elements preserved exactly (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_div</td><td>Number of uniform intervals into which each element is divided. If =0, this element is divided nonuniformly according to sub_wts at this position (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_weights</td><td>2-d array of sub-weights for vector elements divided nonuniformly; each nonzero row must sum to 1. Elements in rows corresponding to nonzero elements of n_div are undefined. (dimensions <code>count</code> * <code>n_sub</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_idx</td><td>2-d array that contains 1's at all positions to be preserved exactly. (dimensions <code>count</code> * <code>n_sub</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_sizes</td><td>If non-null, sub_weights is treated as a jagged 2-D array, with <code>sub_sizes</code> denoting the number of elements in each row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of vector to compress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_samp</td><td>Number of elements to select in systematic resampling </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wt_remain</td><td>Sum of magnitudes of sub-elements not preserved exactly at each position (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">loc_norms</td><td>Sum of magnitudes of elements on each MPI process not preserved exactly </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rand_num</td><td>A random number chosen uniformly on [0, 1). Only the argument from the 0th MPI process is used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_vals</td><td>Magnitudes of elements in compressed vector, including elements preserved exactly </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_idx</td><td>Indices of elements of the compressed vector in the original (input) vector. The 0th column gives the index in the values array, and the 1st gives the index of the subdivided element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in compressed vector on this processor </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
