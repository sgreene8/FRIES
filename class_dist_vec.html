<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fast Randomized Iteration for Electronic Structure: DistVec&lt; el_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fast Randomized Iteration for Electronic Structure
   </div>
   <div id="projectbrief">An implementation of FRI methods for quantum chemistry</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">DistVec&lt; el_type &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for storing and manipulating a sparse vector.  
 <a href="class_dist_vec.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vec__utils_8hpp_source.html">vec_utils.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DistVec&lt; el_type &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_dist_vec.png" usemap="#DistVec_3C_20el_5Ftype_20_3E_map" alt=""/>
  <map id="DistVec_3C_20el_5Ftype_20_3E_map" name="DistVec_3C_20el_5Ftype_20_3E_map">
<area href="class_hub_hol_vec.html" alt="HubHolVec&lt; el_type &gt;" shape="rect" coords="0,56,142,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2aeed718201f8adaabdc687282c91c7c"><td class="memItemLeft" align="right" valign="top"><a id="a2aeed718201f8adaabdc687282c91c7c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DistVec</b> (size_t size, <a class="el" href="class_adder.html">Adder</a>&lt; el_type &gt; *adder, uint8_t n_bits, unsigned int n_elec, std::function&lt; double(const uint8_t *)&gt; diag_fxn, uint8_t n_vecs, std::vector&lt; uint32_t &gt; rns_common, std::vector&lt; uint32_t &gt; rns_distinct)</td></tr>
<tr class="separator:a2aeed718201f8adaabdc687282c91c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2c8538309538a77b1d33e686a35763"><td class="memItemLeft" align="right" valign="top"><a id="a5b2c8538309538a77b1d33e686a35763"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DistVec</b> (size_t size, <a class="el" href="class_adder.html">Adder</a>&lt; el_type &gt; *adder, uint8_t n_bits, unsigned int n_elec, std::vector&lt; uint32_t &gt; rns_common, std::vector&lt; uint32_t &gt; rns_distinct)</td></tr>
<tr class="separator:a5b2c8538309538a77b1d33e686a35763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee8510dec4c808c359e3e219a03bcc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#afee8510dec4c808c359e3e219a03bcc0">DistVec</a> (size_t size, size_t add_size, uint8_t n_bits, unsigned int n_elec, int n_procs, std::function&lt; double(const uint8_t *)&gt; diag_fxn, uint8_t n_vecs, std::vector&lt; uint32_t &gt; rns_common, std::vector&lt; uint32_t &gt; rns_distinct)</td></tr>
<tr class="memdesc:afee8510dec4c808c359e3e219a03bcc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object.  <a href="#afee8510dec4c808c359e3e219a03bcc0">More...</a><br /></td></tr>
<tr class="separator:afee8510dec4c808c359e3e219a03bcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf57e230f4bc6cea94399ac4b9bc9f86"><td class="memItemLeft" align="right" valign="top"><a id="adf57e230f4bc6cea94399ac4b9bc9f86"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DistVec</b> (size_t size, size_t add_size, uint8_t n_bits, unsigned int n_elec, int n_procs, std::vector&lt; uint32_t &gt; rns_common, std::vector&lt; uint32_t &gt; rns_distinct)</td></tr>
<tr class="separator:adf57e230f4bc6cea94399ac4b9bc9f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d89099e44e8a111da2b1bd695b11e30"><td class="memItemLeft" align="right" valign="top"><a id="a7d89099e44e8a111da2b1bd695b11e30"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>n_bits</b> ()</td></tr>
<tr class="separator:a7d89099e44e8a111da2b1bd695b11e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d60f3e38deb306feac5472493aca1c"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a33d60f3e38deb306feac5472493aca1c">gen_orb_list</a> (uint8_t *det, uint8_t *occ_orbs)</td></tr>
<tr class="memdesc:a33d60f3e38deb306feac5472493aca1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate list of occupied orbitals from bit-string representation of a determinant.  <a href="#a33d60f3e38deb306feac5472493aca1c">More...</a><br /></td></tr>
<tr class="separator:a33d60f3e38deb306feac5472493aca1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5a7edba8aeac830ac348ff3bc1cee4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a6a5a7edba8aeac830ac348ff3bc1cee4">dot</a> (<a class="el" href="class_matrix.html">Matrix</a>&lt; uint8_t &gt; &amp;idx2, double *vals2, size_t num2, std::vector&lt; uintmax_t &gt; &amp;hashes2)</td></tr>
<tr class="memdesc:a6a5a7edba8aeac830ac348ff3bc1cee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate dot product.  <a href="#a6a5a7edba8aeac830ac348ff3bc1cee4">More...</a><br /></td></tr>
<tr class="separator:a6a5a7edba8aeac830ac348ff3bc1cee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd7ba8cf2092673c7ba1d24bc60e54a"><td class="memItemLeft" align="right" valign="top"><a id="a4dd7ba8cf2092673c7ba1d24bc60e54a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a4dd7ba8cf2092673c7ba1d24bc60e54a">dot</a> (<a class="el" href="class_matrix.html">Matrix</a>&lt; uint8_t &gt; &amp;idx2, double *vals2, size_t num2)</td></tr>
<tr class="memdesc:a4dd7ba8cf2092673c7ba1d24bc60e54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as function above, except hash values are not provided. <br /></td></tr>
<tr class="separator:a4dd7ba8cf2092673c7ba1d24bc60e54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374ee935b1742ced67e76675ff2e90fd"><td class="memItemLeft" align="right" valign="top"><a id="a374ee935b1742ced67e76675ff2e90fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dot</b> (uint8_t *idx2, double *vals2, size_t num2, <a class="el" href="class_matrix.html">Matrix</a>&lt; double &gt; &amp;results)</td></tr>
<tr class="separator:a374ee935b1742ced67e76675ff2e90fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faed02c0be16c2102371112ebd56c44"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a1faed02c0be16c2102371112ebd56c44">multi_dot</a> (<a class="el" href="class_matrix.html">Matrix</a>&lt; uint8_t &gt; &amp;idx, <a class="el" href="class_matrix.html">Matrix</a>&lt; uint8_t &gt; &amp;occ, double *vals, size_t num)</td></tr>
<tr class="memdesc:a1faed02c0be16c2102371112ebd56c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate dot product across all MPI processes.  <a href="#a1faed02c0be16c2102371112ebd56c44">More...</a><br /></td></tr>
<tr class="separator:a1faed02c0be16c2102371112ebd56c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7655031058893b5af8d4305f2c99121a"><td class="memItemLeft" align="right" valign="top"><a id="a7655031058893b5af8d4305f2c99121a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>perform_dot</b> (<a class="el" href="class_matrix.html">Matrix</a>&lt; double &gt; &amp;results)</td></tr>
<tr class="separator:a7655031058893b5af8d4305f2c99121a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c263ef1caa874d6429ecb12900ed94"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#ad8c263ef1caa874d6429ecb12900ed94">internal_dot</a> (uint8_t idx1, uint8_t idx2)</td></tr>
<tr class="memdesc:ad8c263ef1caa874d6429ecb12900ed94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate dot product of two vectors stored within the internal storage of the <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object.  <a href="#ad8c263ef1caa874d6429ecb12900ed94">More...</a><br /></td></tr>
<tr class="separator:ad8c263ef1caa874d6429ecb12900ed94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2981272989d3f33a9920bb37b408f7ab"><td class="memItemLeft" align="right" valign="top"><a id="a2981272989d3f33a9920bb37b408f7ab"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a2981272989d3f33a9920bb37b408f7ab">expand</a> ()</td></tr>
<tr class="memdesc:a2981272989d3f33a9920bb37b408f7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double the maximum number of elements that can be stored. <br /></td></tr>
<tr class="separator:a2981272989d3f33a9920bb37b408f7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b3a9f94c96c74c695ca0368c616007"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a24b3a9f94c96c74c695ca0368c616007">idx_to_proc</a> (uint8_t *idx)</td></tr>
<tr class="memdesc:a24b3a9f94c96c74c695ca0368c616007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash function mapping vector index to MPI process.  <a href="#a24b3a9f94c96c74c695ca0368c616007">More...</a><br /></td></tr>
<tr class="separator:a24b3a9f94c96c74c695ca0368c616007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60271681725cea7a6441754caeeb33d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#ac60271681725cea7a6441754caeeb33d">idx_to_proc</a> (uint8_t *idx, uint8_t *orbs)</td></tr>
<tr class="memdesc:ac60271681725cea7a6441754caeeb33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash function mapping vector index to MPI process.  <a href="#ac60271681725cea7a6441754caeeb33d">More...</a><br /></td></tr>
<tr class="separator:ac60271681725cea7a6441754caeeb33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d2c85de0507a218ffc3ef1532e32df"><td class="memItemLeft" align="right" valign="top">virtual uintmax_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a01d2c85de0507a218ffc3ef1532e32df">idx_to_hash</a> (uint8_t *idx, uint8_t *orbs)</td></tr>
<tr class="memdesc:a01d2c85de0507a218ffc3ef1532e32df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash function mapping vector index to local hash value.  <a href="#a01d2c85de0507a218ffc3ef1532e32df">More...</a><br /></td></tr>
<tr class="separator:a01d2c85de0507a218ffc3ef1532e32df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6410efa3aa8b77dc50de58196970df1c"><td class="memItemLeft" align="right" valign="top"><a id="a6410efa3aa8b77dc50de58196970df1c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a6410efa3aa8b77dc50de58196970df1c">print_ht</a> ()</td></tr>
<tr class="memdesc:a6410efa3aa8b77dc50de58196970df1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print number of elements in each row of vector hash table. <br /></td></tr>
<tr class="separator:a6410efa3aa8b77dc50de58196970df1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd071b2d41a7cf8c19b1c1427648313a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#acd071b2d41a7cf8c19b1c1427648313a">add</a> (uint8_t *idx, el_type val, uint8_t ini_flag)</td></tr>
<tr class="memdesc:acd071b2d41a7cf8c19b1c1427648313a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element to the <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object.  <a href="#acd071b2d41a7cf8c19b1c1427648313a">More...</a><br /></td></tr>
<tr class="separator:acd071b2d41a7cf8c19b1c1427648313a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9136e3d3d597577a98d30deaa13d9dbf"><td class="memItemLeft" align="right" valign="top"><a id="a9136e3d3d597577a98d30deaa13d9dbf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add</b> (uint8_t *idx, el_type *vals, size_t n_vals, uint8_t ini_flag)</td></tr>
<tr class="separator:a9136e3d3d597577a98d30deaa13d9dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6c58d32778066070b6568ecfc7e089"><td class="memItemLeft" align="right" valign="top"><a id="a7f6c58d32778066070b6568ecfc7e089"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add</b> (uint8_t *idx, uint8_t *orbs, el_type val, uint8_t ini_flag)</td></tr>
<tr class="separator:a7f6c58d32778066070b6568ecfc7e089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150ee5d37292d3dbadbd794f285c385f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a150ee5d37292d3dbadbd794f285c385f">perform_add</a> (size_t origin)</td></tr>
<tr class="memdesc:a150ee5d37292d3dbadbd794f285c385f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incorporate elements from the <a class="el" href="class_adder.html" title="Class for adding elements to a DistVec object. ">Adder</a> buffer into the vector.  <a href="#a150ee5d37292d3dbadbd794f285c385f">More...</a><br /></td></tr>
<tr class="separator:a150ee5d37292d3dbadbd794f285c385f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcec573bb59098e0eb94500371d8be3"><td class="memItemLeft" align="right" valign="top"><a id="a1fcec573bb59098e0eb94500371d8be3"></a>
ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a1fcec573bb59098e0eb94500371d8be3">pop_stack</a> ()</td></tr>
<tr class="memdesc:a1fcec573bb59098e0eb94500371d8be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of an unused intermediate index in the <code>indices_</code> array, or -1 if none exists. <br /></td></tr>
<tr class="separator:a1fcec573bb59098e0eb94500371d8be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf594a43c2bee02f5b24751597aa42de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#abf594a43c2bee02f5b24751597aa42de">del_at_pos</a> (size_t pos)</td></tr>
<tr class="memdesc:abf594a43c2bee02f5b24751597aa42de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an element from the vector.  <a href="#abf594a43c2bee02f5b24751597aa42de">More...</a><br /></td></tr>
<tr class="separator:abf594a43c2bee02f5b24751597aa42de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b66d5e31b5dc18b314c8a68163263bd"><td class="memItemLeft" align="right" valign="top"><a id="a4b66d5e31b5dc18b314c8a68163263bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a4b66d5e31b5dc18b314c8a68163263bd">cleanup</a> ()</td></tr>
<tr class="memdesc:a4b66d5e31b5dc18b314c8a68163263bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove zero elements from vector (if zero in all internal vectors) <br /></td></tr>
<tr class="separator:a4b66d5e31b5dc18b314c8a68163263bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9056cc6d89ede41f4dd781a3510ca33"><td class="memItemLeft" align="right" valign="top"><a id="aa9056cc6d89ede41f4dd781a3510ca33"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#aa9056cc6d89ede41f4dd781a3510ca33">fix_min_del_idx</a> ()</td></tr>
<tr class="memdesc:aa9056cc6d89ede41f4dd781a3510ca33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <code>min_del_idx</code> parameter at <code>curr_size_</code>. <br /></td></tr>
<tr class="separator:aa9056cc6d89ede41f4dd781a3510ca33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5579e3c067281c35295e240196a545"><td class="memItemLeft" align="right" valign="top"><a id="aea5579e3c067281c35295e240196a545"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_min_del_idx</b> (size_t idx)</td></tr>
<tr class="separator:aea5579e3c067281c35295e240196a545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63d128772610328f5cddf75a728c52e"><td class="memItemLeft" align="right" valign="top">el_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#af63d128772610328f5cddf75a728c52e">values</a> () const</td></tr>
<tr class="separator:af63d128772610328f5cddf75a728c52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb25c6ba83b19569b737f89e558b032"><td class="memItemLeft" align="right" valign="top"><a id="adeb25c6ba83b19569b737f89e558b032"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_vecs</b> () const</td></tr>
<tr class="separator:adeb25c6ba83b19569b737f89e558b032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67166e3ee132abee21b5b3171f66bb00"><td class="memItemLeft" align="right" valign="top"><a id="a67166e3ee132abee21b5b3171f66bb00"></a>
<a class="el" href="class_matrix.html">Matrix</a>&lt; uint8_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>indices</b> ()</td></tr>
<tr class="separator:a67166e3ee132abee21b5b3171f66bb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8ffed11e0aba136ad2d3b15467ed29"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#aee8ffed11e0aba136ad2d3b15467ed29">curr_size</a> () const</td></tr>
<tr class="separator:aee8ffed11e0aba136ad2d3b15467ed29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c0e98857801ac20c5dc3e9a1884e58"><td class="memItemLeft" align="right" valign="top"><a id="af8c0e98857801ac20c5dc3e9a1884e58"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>adder_size</b> () const</td></tr>
<tr class="separator:af8c0e98857801ac20c5dc3e9a1884e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedc03f73a7cad1768c3cabb4b3b731b"><td class="memItemLeft" align="right" valign="top"><a id="abedc03f73a7cad1768c3cabb4b3b731b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#abedc03f73a7cad1768c3cabb4b3b731b">max_size</a> () const</td></tr>
<tr class="memdesc:abedc03f73a7cad1768c3cabb4b3b731b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of elements the vector can store. <br /></td></tr>
<tr class="separator:abedc03f73a7cad1768c3cabb4b3b731b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae339427cbc27c233535ebeeb5cc05574"><td class="memItemLeft" align="right" valign="top"><a id="ae339427cbc27c233535ebeeb5cc05574"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#ae339427cbc27c233535ebeeb5cc05574">n_nonz</a> () const</td></tr>
<tr class="memdesc:ae339427cbc27c233535ebeeb5cc05574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current number of nonzero elements in the vector. <br /></td></tr>
<tr class="separator:ae339427cbc27c233535ebeeb5cc05574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb5b844f19be62b003169fda183b44d"><td class="memItemLeft" align="right" valign="top"><a id="a6cb5b844f19be62b003169fda183b44d"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>tot_sgn_coh</b> () const</td></tr>
<tr class="separator:a6cb5b844f19be62b003169fda183b44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4db014fa6a2deb1f8e6ec7ba580a2f"><td class="memItemLeft" align="right" valign="top"><a id="a1a4db014fa6a2deb1f8e6ec7ba580a2f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a1a4db014fa6a2deb1f8e6ec7ba580a2f">add_vecs</a> (uint8_t idx1, uint8_t idx2)</td></tr>
<tr class="memdesc:a1a4db014fa6a2deb1f8e6ec7ba580a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the vector at <code>idx2</code> to the one at <code>idx1</code>. <br /></td></tr>
<tr class="separator:a1a4db014fa6a2deb1f8e6ec7ba580a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41603e63a63ab3831bb3e6fb435ecd82"><td class="memItemLeft" align="right" valign="top"><a id="a41603e63a63ab3831bb3e6fb435ecd82"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a41603e63a63ab3831bb3e6fb435ecd82">add_vecs</a> (uint8_t idx1, uint8_t idx2, el_type c)</td></tr>
<tr class="memdesc:a41603e63a63ab3831bb3e6fb435ecd82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constant times the vector at <code>idx2</code> to the one at <code>idx1</code>. <br /></td></tr>
<tr class="separator:a41603e63a63ab3831bb3e6fb435ecd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa7da2eaffe529630fd1df922fa033d"><td class="memItemLeft" align="right" valign="top"><a id="a2fa7da2eaffe529630fd1df922fa033d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a2fa7da2eaffe529630fd1df922fa033d">copy_vec</a> (uint8_t src, uint8_t dst)</td></tr>
<tr class="memdesc:a2fa7da2eaffe529630fd1df922fa033d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the vector at <code>src</code> to the one at <code>dst</code>. <br /></td></tr>
<tr class="separator:a2fa7da2eaffe529630fd1df922fa033d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3edca97380d03faa3453e6db89db87"><td class="memItemLeft" align="right" valign="top"><a id="a1e3edca97380d03faa3453e6db89db87"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a1e3edca97380d03faa3453e6db89db87">weight_vec</a> (uint8_t idx1, uint8_t idx2, double expo)</td></tr>
<tr class="memdesc:a1e3edca97380d03faa3453e6db89db87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weight elements in the first vector v(<code>idx1</code>, i) by those in the second [1 + |v(<code>idx2</code>, i)|]^<code>expo</code>. <br /></td></tr>
<tr class="separator:a1e3edca97380d03faa3453e6db89db87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7e76962a282e1d65c5722cb6f1200d"><td class="memItemLeft" align="right" valign="top"><a id="a3a7e76962a282e1d65c5722cb6f1200d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a3a7e76962a282e1d65c5722cb6f1200d">zero_vec</a> ()</td></tr>
<tr class="memdesc:a3a7e76962a282e1d65c5722cb6f1200d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero all vector elements at <code>curr_vec_idx_</code> without removing them from the hash table. <br /></td></tr>
<tr class="separator:a3a7e76962a282e1d65c5722cb6f1200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ab75faf918c10ec8bee5bbdc1ddde9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a79ab75faf918c10ec8bee5bbdc1ddde9">set_curr_vec_idx</a> (uint8_t new_idx)</td></tr>
<tr class="memdesc:a79ab75faf918c10ec8bee5bbdc1ddde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the internal vector used to store elements in this <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object.  <a href="#a79ab75faf918c10ec8bee5bbdc1ddde9">More...</a><br /></td></tr>
<tr class="separator:a79ab75faf918c10ec8bee5bbdc1ddde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d37615842300d029c130a5480e7029"><td class="memItemLeft" align="right" valign="top"><a id="ad8d37615842300d029c130a5480e7029"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>curr_vec_idx</b> () const</td></tr>
<tr class="separator:ad8d37615842300d029c130a5480e7029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4434769fb34188dc774b56aef5a7d418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a4434769fb34188dc774b56aef5a7d418">add_elements</a> (uint8_t *indices, el_type *vals, size_t count, size_t origin)</td></tr>
<tr class="memdesc:a4434769fb34188dc774b56aef5a7d418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add elements destined for this process to the <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object.  <a href="#a4434769fb34188dc774b56aef5a7d418">More...</a><br /></td></tr>
<tr class="separator:a4434769fb34188dc774b56aef5a7d418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90a710cca5e2851082b1537ca65add9"><td class="memItemLeft" align="right" valign="top">el_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#ae90a710cca5e2851082b1537ca65add9">operator[]</a> (size_t pos)</td></tr>
<tr class="memdesc:ae90a710cca5e2851082b1537ca65add9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a value in the <code>values_</code> matrix of the <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object.  <a href="#ae90a710cca5e2851082b1537ca65add9">More...</a><br /></td></tr>
<tr class="separator:ae90a710cca5e2851082b1537ca65add9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8a3dcbc07c4a75267a47760b278128"><td class="memItemLeft" align="right" valign="top"><a id="a3c8a3dcbc07c4a75267a47760b278128"></a>
el_type *&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (size_t vec_idx, size_t pos)</td></tr>
<tr class="separator:a3c8a3dcbc07c4a75267a47760b278128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad408324cf7f8eac3b92ea3ff69783f49"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#ad408324cf7f8eac3b92ea3ff69783f49">orbs_at_pos</a> (size_t pos)</td></tr>
<tr class="memdesc:ad408324cf7f8eac3b92ea3ff69783f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the list of occupied orbitals corresponding to an existing determinant index in the vector.  <a href="#ad408324cf7f8eac3b92ea3ff69783f49">More...</a><br /></td></tr>
<tr class="separator:ad408324cf7f8eac3b92ea3ff69783f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba00dd8795ee3b81e89af3e7aa461690"><td class="memItemLeft" align="right" valign="top"><a id="aba00dd8795ee3b81e89af3e7aa461690"></a>
<a class="el" href="class_matrix.html">Matrix</a>&lt; uint8_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>occ_orbs</b> ()</td></tr>
<tr class="separator:aba00dd8795ee3b81e89af3e7aa461690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a8ddbb121c3703a32432c7acbbbcd9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#ad1a8ddbb121c3703a32432c7acbbbcd9">matr_el_at_pos</a> (size_t pos)</td></tr>
<tr class="memdesc:ad1a8ddbb121c3703a32432c7acbbbcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the diagonal matrix element corresponding to an element in the <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object.  <a href="#ad1a8ddbb121c3703a32432c7acbbbcd9">More...</a><br /></td></tr>
<tr class="separator:ad1a8ddbb121c3703a32432c7acbbbcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d32fc96fd197e011a3cce2c4fd49436"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a2d32fc96fd197e011a3cce2c4fd49436">local_norm</a> () const</td></tr>
<tr class="memdesc:a2d32fc96fd197e011a3cce2c4fd49436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the sum of the magnitudes of the vector elements on each MPI process.  <a href="#a2d32fc96fd197e011a3cce2c4fd49436">More...</a><br /></td></tr>
<tr class="separator:a2d32fc96fd197e011a3cce2c4fd49436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1cad068e412945886c845c61728621"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#afc1cad068e412945886c845c61728621">two_norm</a> () const</td></tr>
<tr class="memdesc:afc1cad068e412945886c845c61728621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the sum of the squares of the vector elements on each MPI process.  <a href="#afc1cad068e412945886c845c61728621">More...</a><br /></td></tr>
<tr class="separator:afc1cad068e412945886c845c61728621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109243150a288fbf669bc55cdfce5ee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a109243150a288fbf669bc55cdfce5ee6">save</a> (const std::string &amp;path, uint8_t start_idx, uint8_t n_vecs)</td></tr>
<tr class="memdesc:a109243150a288fbf669bc55cdfce5ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object to disk in binary format.  <a href="#a109243150a288fbf669bc55cdfce5ee6">More...</a><br /></td></tr>
<tr class="separator:a109243150a288fbf669bc55cdfce5ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b362e16ea3ab7f638aefe376f79f59"><td class="memItemLeft" align="right" valign="top"><a id="a86b362e16ea3ab7f638aefe376f79f59"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>save</b> (const std::string &amp;path)</td></tr>
<tr class="separator:a86b362e16ea3ab7f638aefe376f79f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164460d46b2c179f040bd0ed7e3ae7a9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a164460d46b2c179f040bd0ed7e3ae7a9">load</a> (const std::string &amp;path, uint8_t n_vecs)</td></tr>
<tr class="memdesc:a164460d46b2c179f040bd0ed7e3ae7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from disk in binary format.  <a href="#a164460d46b2c179f040bd0ed7e3ae7a9">More...</a><br /></td></tr>
<tr class="separator:a164460d46b2c179f040bd0ed7e3ae7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0834ac9c046be5476807da17310962"><td class="memItemLeft" align="right" valign="top"><a id="a4e0834ac9c046be5476807da17310962"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>load</b> (const std::string &amp;path)</td></tr>
<tr class="separator:a4e0834ac9c046be5476807da17310962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561609b0a43372b70a8a340062536453"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a561609b0a43372b70a8a340062536453">init_dense</a> (const std::string &amp;read_path, const std::string &amp;save_dir)</td></tr>
<tr class="memdesc:a561609b0a43372b70a8a340062536453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all of the vector indices defining the dense subspace from disk, and initialize the corresponding vector elements to 0.  <a href="#a561609b0a43372b70a8a340062536453">More...</a><br /></td></tr>
<tr class="separator:a561609b0a43372b70a8a340062536453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cf6a53ed81d75c50e3f0900deb9c91"><td class="memItemLeft" align="right" valign="top">el_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a59cf6a53ed81d75c50e3f0900deb9c91">dense_norm</a> ()</td></tr>
<tr class="memdesc:a59cf6a53ed81d75c50e3f0900deb9c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the one-norm of the vector in the dense subspace.  <a href="#a59cf6a53ed81d75c50e3f0900deb9c91">More...</a><br /></td></tr>
<tr class="separator:a59cf6a53ed81d75c50e3f0900deb9c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23d126899918783ff4e30be6154862e"><td class="memItemLeft" align="right" valign="top"><a id="af23d126899918783ff4e30be6154862e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#af23d126899918783ff4e30be6154862e">collect_procs</a> ()</td></tr>
<tr class="memdesc:af23d126899918783ff4e30be6154862e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all of the vector elements from other MPI processes and accumulate them in the vector on each process. <br /></td></tr>
<tr class="separator:af23d126899918783ff4e30be6154862e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae2d06aeafbc3d17f4d345274b8c10721"><td class="memItemLeft" align="right" valign="top"><a id="ae2d06aeafbc3d17f4d345274b8c10721"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>initialize_at_pos</b> (size_t pos, uint8_t *orbs)</td></tr>
<tr class="separator:ae2d06aeafbc3d17f4d345274b8c10721"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a25e874c2bb63f71538e04ce756f1e96a"><td class="memItemLeft" align="right" valign="top"><a id="a25e874c2bb63f71538e04ce756f1e96a"></a>
<a class="el" href="class_matrix.html">Matrix</a>&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a25e874c2bb63f71538e04ce756f1e96a">indices_</a></td></tr>
<tr class="memdesc:a25e874c2bb63f71538e04ce756f1e96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of indices of vector elements. <br /></td></tr>
<tr class="separator:a25e874c2bb63f71538e04ce756f1e96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c71cd8b63dbd5e33c81719592b68977"><td class="memItemLeft" align="right" valign="top"><a id="a6c71cd8b63dbd5e33c81719592b68977"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a6c71cd8b63dbd5e33c81719592b68977">max_size_</a></td></tr>
<tr class="memdesc:a6c71cd8b63dbd5e33c81719592b68977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of vector elements that can be stored. <br /></td></tr>
<tr class="separator:a6c71cd8b63dbd5e33c81719592b68977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26b0f6faf6496808fda884a82aca547"><td class="memItemLeft" align="right" valign="top"><a id="af26b0f6faf6496808fda884a82aca547"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#af26b0f6faf6496808fda884a82aca547">curr_size_</a></td></tr>
<tr class="memdesc:af26b0f6faf6496808fda884a82aca547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current number of vector elements stored, including intermediate zeroes. <br /></td></tr>
<tr class="separator:af26b0f6faf6496808fda884a82aca547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822f5c81631a9426ee9af8f58aa1466f"><td class="memItemLeft" align="right" valign="top"><a id="a822f5c81631a9426ee9af8f58aa1466f"></a>
<a class="el" href="class_matrix.html">Matrix</a>&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a822f5c81631a9426ee9af8f58aa1466f">occ_orbs_</a></td></tr>
<tr class="memdesc:a822f5c81631a9426ee9af8f58aa1466f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_matrix.html" title="A class for representing and manipulating matrices with variable dimension sizes. ...">Matrix</a> containing lists of occupied orbitals for each determniant index. <br /></td></tr>
<tr class="separator:a822f5c81631a9426ee9af8f58aa1466f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4977cbc19dc131994e3a41df2c992a51"><td class="memItemLeft" align="right" valign="top"><a id="a4977cbc19dc131994e3a41df2c992a51"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a4977cbc19dc131994e3a41df2c992a51">n_bits_</a></td></tr>
<tr class="memdesc:a4977cbc19dc131994e3a41df2c992a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits used to encode each index of the vector. <br /></td></tr>
<tr class="separator:a4977cbc19dc131994e3a41df2c992a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5827586c767341a1f968544cfebdbd"><td class="memItemLeft" align="right" valign="top"><a id="aea5827586c767341a1f968544cfebdbd"></a>
<a class="el" href="class_hash_table.html">HashTable</a>&lt; ssize_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#aea5827586c767341a1f968544cfebdbd">vec_hash_</a></td></tr>
<tr class="memdesc:aea5827586c767341a1f968544cfebdbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash table for quickly finding indices in <code>indices_</code>. <br /></td></tr>
<tr class="separator:aea5827586c767341a1f968544cfebdbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0281f96cdde11900e767fccf81c8afe6"><td class="memItemLeft" align="right" valign="top"><a id="a0281f96cdde11900e767fccf81c8afe6"></a>
<a class="el" href="class_hash_table.html">HashTable</a>&lt; ssize_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a0281f96cdde11900e767fccf81c8afe6">proc_hash_</a></td></tr>
<tr class="memdesc:a0281f96cdde11900e767fccf81c8afe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nothing is stored in this hash table, but its hash function is used to map indices to processes. <br /></td></tr>
<tr class="separator:a0281f96cdde11900e767fccf81c8afe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1288311fc2a2c7e673183254c1098b6"><td class="memItemLeft" align="right" valign="top"><a id="af1288311fc2a2c7e673183254c1098b6"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#af1288311fc2a2c7e673183254c1098b6">nonini_occ_add</a></td></tr>
<tr class="memdesc:af1288311fc2a2c7e673183254c1098b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of times an addition from a noninitiator determinant to an occupied determinant occurred. <br /></td></tr>
<tr class="separator:af1288311fc2a2c7e673183254c1098b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6362a0c4cbcd42d43b433a71a880c68"><td class="memItemLeft" align="right" valign="top"><a id="ab6362a0c4cbcd42d43b433a71a880c68"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#ab6362a0c4cbcd42d43b433a71a880c68">matr_el_</a></td></tr>
<tr class="memdesc:ab6362a0c4cbcd42d43b433a71a880c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of pre-calculated diagonal matrix elements associated with each vector element. <br /></td></tr>
<tr class="separator:ab6362a0c4cbcd42d43b433a71a880c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaacf404ce1931e89838cd90a3c5c694"><td class="memItemLeft" align="right" valign="top"><a id="aaaacf404ce1931e89838cd90a3c5c694"></a>
std::function&lt; double(const uint8_t *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#aaaacf404ce1931e89838cd90a3c5c694">diag_calc_</a></td></tr>
<tr class="memdesc:aaaacf404ce1931e89838cd90a3c5c694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a function used to calculate diagonal matrix elements for elements in this vector. <br /></td></tr>
<tr class="separator:aaaacf404ce1931e89838cd90a3c5c694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a0775d0dcd98af7ec68251f9ff11eb"><td class="memItemLeft" align="right" valign="top"><a id="a71a0775d0dcd98af7ec68251f9ff11eb"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dist_vec.html#a71a0775d0dcd98af7ec68251f9ff11eb">active_pos_</a></td></tr>
<tr class="memdesc:a71a0775d0dcd98af7ec68251f9ff11eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean vector indicating which indices are currently in the vector's hash table. <br /></td></tr>
<tr class="separator:a71a0775d0dcd98af7ec68251f9ff11eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class el_type&gt;<br />
class DistVec&lt; el_type &gt;</h3>

<p>Class for storing and manipulating a sparse vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">el_type</td><td>Type of elements in the vector Elements of the vector are distributed across many MPI processes, and hashing is used for efficient access. Each index is uniquely associated with a particular process, as determined its hash value. This class allows for multiple element values to be associated with each vector index, allowing for the storage of multiple sparse vectors in a single <code><a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a></code> object. This is useful for manipulating multiple sparse vectors that are likely to have many nonzero elements in common. The values for all vectors are stored in the <code>values_</code> matrix, and <code><a class="el" href="class_hash_table.html" title="Hash table used to to index Slater determinant indices in the solution vector. ">HashTable</a></code> objects handle the indexing for the elements in all vectors. This class also supports much of the logic used in ran </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afee8510dec4c808c359e3e219a03bcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee8510dec4c808c359e3e219a03bcc0">&#9670;&nbsp;</a></span>DistVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_dist_vec.html">DistVec</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>add_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>n_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_elec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_procs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(const uint8_t *)&gt;&#160;</td>
          <td class="paramname"><em>diag_fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>n_vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>rns_common</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>rns_distinct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of elements to be stored in the vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add_size</td><td>Maximum number of elements per processor to use in <a class="el" href="class_adder.html" title="Class for adding elements to a DistVec object. ">Adder</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_bits</td><td>Number of bits used to encode each index of the vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_elec</td><td>Number of electrons represented in each vector index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_procs</td><td>Number of MPI processes over which to distribute vector elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diag_fxn</td><td>Function used to calculate the diagonal matrix element for a vector element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_vecs</td><td>Number of vectors to store in parallel in this <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rns_common</td><td>Vector of random numbers that is the same on all MPI processes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rns_distinct</td><td>A different vector of random numbers that need not be common to all MPI processes, but should not be the same as <code>rns_common</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acd071b2d41a7cf8c19b1c1427648313a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd071b2d41a7cf8c19b1c1427648313a">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool add </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">el_type&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ini_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an element to the <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object. </p>
<p>The element will be added to a buffer for later processing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The index of the element in the vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value of the added element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ini_flag</td><td>Either 1 or 0. If 0, will only be added to a determinant that is already occupied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if buffer is not yet full, false otherwise </dd></dl>

</div>
</div>
<a id="a4434769fb34188dc774b56aef5a7d418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4434769fb34188dc774b56aef5a7d418">&#9670;&nbsp;</a></span>add_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void add_elements </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">el_type *&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add elements destined for this process to the <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>Indices of the elements to be added </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vals</td><td>Values of the elements to be added. Upon return, contains 2nd-order perturbative correction (see Ghanem et al., JCP 151, 224108, 2019) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee8ffed11e0aba136ad2d3b15467ed29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8ffed11e0aba136ad2d3b15467ed29">&#9670;&nbsp;</a></span>curr_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t curr_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current number of elements in use in the <code>indices_</code> and <code>values</code> arrays </dd></dl>

</div>
</div>
<a id="abf594a43c2bee02f5b24751597aa42de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf594a43c2bee02f5b24751597aa42de">&#9670;&nbsp;</a></span>del_at_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void del_at_pos </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete an element from the vector. </p>
<p>Removes an element from the vector and modifies the hash table accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The position of the element to be deleted in <code>indices_</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59cf6a53ed81d75c50e3f0900deb9c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cf6a53ed81d75c50e3f0900deb9c91">&#9670;&nbsp;</a></span>dense_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">el_type dense_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the one-norm of the vector in the dense subspace. </p>
<dl class="section return"><dt>Returns</dt><dd>The total norm from all processes </dd></dl>

</div>
</div>
<a id="a6a5a7edba8aeac830ac348ff3bc1cee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5a7edba8aeac830ac348ff3bc1cee4">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a>&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vals2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uintmax_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>hashes2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate dot product. </p>
<p>Calculates dot product of the portion of a <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object stored on each MPI process with a local sparse vector (such that the local results could be added)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx2</td><td>Indices of elements in the local vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vals2</td><td>Values of elements in the local vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num2</td><td>Number of elements in the local vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashes2</td><td>hash values of the indices of the local vector from the hash table of vec </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the dot product </dd></dl>

</div>
</div>
<a id="a33d60f3e38deb306feac5472493aca1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d60f3e38deb306feac5472493aca1c">&#9670;&nbsp;</a></span>gen_orb_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint8_t gen_orb_list </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>occ_orbs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate list of occupied orbitals from bit-string representation of a determinant. </p>
<p>This implementation uses the procedure in Sec. 3.1 of Booth et al. (2014) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">det</td><td>bit string to be parsed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">occ_orbs</td><td>Occupied orbitals in the determinant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of 1 bits in the bit string </dd></dl>

<p>Reimplemented in <a class="el" href="class_hub_hol_vec.html#a5371290fdfad06afca8af5374dac0dbe">HubHolVec&lt; el_type &gt;</a>.</p>

</div>
</div>
<a id="a01d2c85de0507a218ffc3ef1532e32df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d2c85de0507a218ffc3ef1532e32df">&#9670;&nbsp;</a></span>idx_to_hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uintmax_t idx_to_hash </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>orbs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash function mapping vector index to local hash value. </p>
<p>The local hash value is used to find the index on a particular processor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Vector index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">orbs</td><td>Array of occupied orbital indices in <code>idx</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash value </dd></dl>

<p>Reimplemented in <a class="el" href="class_hub_hol_vec.html#ac020f8a410cca6f390f4ba97900aa142">HubHolVec&lt; el_type &gt;</a>.</p>

</div>
</div>
<a id="a24b3a9f94c96c74c695ca0368c616007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b3a9f94c96c74c695ca0368c616007">&#9670;&nbsp;</a></span>idx_to_proc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int idx_to_proc </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash function mapping vector index to MPI process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Vector index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>process index from hash value </dd></dl>

<p>Reimplemented in <a class="el" href="class_hub_hol_vec.html#a8ab8f25befbebd1072cb83eb47d91bbb">HubHolVec&lt; el_type &gt;</a>.</p>

</div>
</div>
<a id="ac60271681725cea7a6441754caeeb33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60271681725cea7a6441754caeeb33d">&#9670;&nbsp;</a></span>idx_to_proc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int idx_to_proc </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>orbs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash function mapping vector index to MPI process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Vector index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orbs</td><td>Array of occupied orbital indices in <code>idx</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>process index from hash value </dd></dl>

</div>
</div>
<a id="a561609b0a43372b70a8a340062536453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561609b0a43372b70a8a340062536453">&#9670;&nbsp;</a></span>init_dense()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t init_dense </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>read_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>save_dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load all of the vector indices defining the dense subspace from disk, and initialize the corresponding vector elements to 0. </p>
<p>Indices must be stored on disk as ≤64-bit integers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">read_path</td><td>Path to the file where the indices are stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">save_dir</td><td>Directory in which to store a file containing the length of the dense subspace on each MPI process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the dense subspace </dd></dl>

</div>
</div>
<a id="ad8c263ef1caa874d6429ecb12900ed94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c263ef1caa874d6429ecb12900ed94">&#9670;&nbsp;</a></span>internal_dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double internal_dot </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idx2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate dot product of two vectors stored within the internal storage of the <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx1</td><td>Row index of one of the input vectors within the <code>values_</code> matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx2</td><td>Row index of one of the input vectors within the <code>values_</code> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the dot product </dd></dl>

</div>
</div>
<a id="a164460d46b2c179f040bd0ed7e3ae7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164460d46b2c179f040bd0ed7e3ae7a9">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>n_vecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a vector from disk in binary format. </p>
<p>The vector indices from each MPI process are read from the file [path]dets[MPI rank].dat, and the values from [path]vals[MPI rank].dat</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Location from which to read the files </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_vecs</td><td>Number of vectors to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the dense subspace </dd></dl>

</div>
</div>
<a id="a2d32fc96fd197e011a3cce2c4fd49436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d32fc96fd197e011a3cce2c4fd49436">&#9670;&nbsp;</a></span>local_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double local_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the sum of the magnitudes of the vector elements on each MPI process. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of the magnitudes on this process </dd></dl>

</div>
</div>
<a id="ad1a8ddbb121c3703a32432c7acbbbcd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a8ddbb121c3703a32432c7acbbbcd9">&#9670;&nbsp;</a></span>matr_el_at_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double matr_el_at_pos </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the diagonal matrix element corresponding to an element in the <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The position of the corresponding index in the <code>indices_</code> array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1faed02c0be16c2102371112ebd56c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1faed02c0be16c2102371112ebd56c44">&#9670;&nbsp;</a></span>multi_dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double multi_dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a>&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a>&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>occ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate dot product across all MPI processes. </p>
<p>Unlike the <code>dot</code> function above, this function calculates the overlap between vector elements on all MPI process and those in the inputted vectors</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Bit string of elements to dot with this vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">occ</td><td>List of occupied orbitals in each bit string index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td>Values of elements to dot </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of elements to be dotted on this process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the dot product </dd></dl>

</div>
</div>
<a id="ae90a710cca5e2851082b1537ca65add9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90a710cca5e2851082b1537ca65add9">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">el_type* operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to a value in the <code>values_</code> matrix of the <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The position of the corresponding index in the <code>indices_</code> array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad408324cf7f8eac3b92ea3ff69783f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad408324cf7f8eac3b92ea3ff69783f49">&#9670;&nbsp;</a></span>orbs_at_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* orbs_at_pos </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the list of occupied orbitals corresponding to an existing determinant index in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The row index of the index in the <code>indices_</code> matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a150ee5d37292d3dbadbd794f285c385f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150ee5d37292d3dbadbd794f285c385f">&#9670;&nbsp;</a></span>perform_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void perform_add </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>origin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Incorporate elements from the <a class="el" href="class_adder.html" title="Class for adding elements to a DistVec object. ">Adder</a> buffer into the vector. </p>
<p>Elements are added if the corresponding element in <code>origin</code> is nonzero. Otherwise, only elements with a nonzero initiator flag are added </p>

</div>
</div>
<a id="a109243150a288fbf669bc55cdfce5ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109243150a288fbf669bc55cdfce5ee6">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>start_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>n_vecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save a <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object to disk in binary format. </p>
<p>The vector indices from each MPI process are stored in the file [path]dets[MPI rank].dat, and the values at [path]vals[MPI rank].dat Only the values from <code>start_idx</code> to <code>start_idx</code> + <code>n_vecs</code> - 1 are saved</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Location where the files are to be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_idx</td><td>Index of the first vector to write to disk </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_vecs</td><td>Number of vectors to write to disk </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79ab75faf918c10ec8bee5bbdc1ddde9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ab75faf918c10ec8bee5bbdc1ddde9">&#9670;&nbsp;</a></span>set_curr_vec_idx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_curr_vec_idx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>new_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the internal vector used to store elements in this <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_idx</td><td>Index of the internal vector to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc1cad068e412945886c845c61728621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1cad068e412945886c845c61728621">&#9670;&nbsp;</a></span>two_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double two_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the sum of the squares of the vector elements on each MPI process. </p>
<dl class="section return"><dt>Returns</dt><dd>The two-norm of the elements on this process </dd></dl>

</div>
</div>
<a id="af63d128772610328f5cddf75a728c52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63d128772610328f5cddf75a728c52e">&#9670;&nbsp;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">el_type* values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The array used to store values in the <a class="el" href="class_dist_vec.html" title="Class for storing and manipulating a sparse vector. ">DistVec</a> object </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/sgreene8/FRIES/FRIES/<a class="el" href="vec__utils_8hpp_source.html">vec_utils.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
