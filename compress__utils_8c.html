<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fast Randomized Iteration for Electronic Structure: /Users/samuelgreene/Documents/U of C Research/C code/FRIes/FRIES/compress_utils.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fast Randomized Iteration for Electronic Structure
   </div>
   <div id="projectbrief">An implementation of FRI methods for quantum chemistry</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_607347b14e208e050cf2976c6f5bb11f.html">FRIES</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">compress_utils.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utilities for compressing vectors stochastically using the FRI framework.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="compress__utils_8h_source.html">compress_utils.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1e6d1037941be464363981d4b3e4fe52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8c.html#a1e6d1037941be464363981d4b3e4fe52">round_binomially</a> (double p, unsigned int n, <a class="el" href="structmt__struct.html">mt_struct</a> *mt_ptr)</td></tr>
<tr class="memdesc:a1e6d1037941be464363981d4b3e4fe52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a non-integral number binomially.  <a href="compress__utils_8c.html#a1e6d1037941be464363981d4b3e4fe52">More...</a><br /></td></tr>
<tr class="separator:a1e6d1037941be464363981d4b3e4fe52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1355ac3c7b200e2a3e7d9728783ff6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8c.html#a8a1355ac3c7b200e2a3e7d9728783ff6">find_preserve</a> (double *values, size_t *srt_idx, int *keep_idx, size_t count, unsigned int *n_samp, double *global_norm)</td></tr>
<tr class="memdesc:a8a1355ac3c7b200e2a3e7d9728783ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the greatest-magnitude elements of a vector.  <a href="compress__utils_8c.html#a8a1355ac3c7b200e2a3e7d9728783ff6">More...</a><br /></td></tr>
<tr class="separator:a8a1355ac3c7b200e2a3e7d9728783ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa514ed6284e1c7ae31e0907621aa3da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8c.html#aaa514ed6284e1c7ae31e0907621aa3da">sum_mpi_d</a> (double local, double *global, int my_rank, int n_procs)</td></tr>
<tr class="memdesc:aaa514ed6284e1c7ae31e0907621aa3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum a variable across all MPI processes.  <a href="compress__utils_8c.html#aaa514ed6284e1c7ae31e0907621aa3da">More...</a><br /></td></tr>
<tr class="separator:aaa514ed6284e1c7ae31e0907621aa3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac033a06f40f9f0b12a18b5002a249b18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8c.html#ac033a06f40f9f0b12a18b5002a249b18">sum_mpi_i</a> (int local, int *global, int my_rank, int n_procs)</td></tr>
<tr class="memdesc:ac033a06f40f9f0b12a18b5002a249b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum a variable across all MPI processes.  <a href="compress__utils_8c.html#ac033a06f40f9f0b12a18b5002a249b18">More...</a><br /></td></tr>
<tr class="separator:ac033a06f40f9f0b12a18b5002a249b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbd13c575f5d56f4dbf0a510dbad157"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8c.html#aefbd13c575f5d56f4dbf0a510dbad157">seed_sys</a> (double *norms, double *rn, unsigned int n_samp)</td></tr>
<tr class="memdesc:aefbd13c575f5d56f4dbf0a510dbad157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set-up for performing systematic compression across many MPI processes.  <a href="compress__utils_8c.html#aefbd13c575f5d56f4dbf0a510dbad157">More...</a><br /></td></tr>
<tr class="separator:aefbd13c575f5d56f4dbf0a510dbad157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28de42583a3739fb7dde3653f15f68d2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8c.html#a28de42583a3739fb7dde3653f15f68d2">find_keep_sub</a> (double *values, unsigned int *n_div, size_t n_sub, double(*sub_weights)[n_sub], int(*keep_idx)[n_sub], size_t count, unsigned int *n_samp, double *wt_remain)</td></tr>
<tr class="memdesc:a28de42583a3739fb7dde3653f15f68d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify elements to preserve exactly according to the FRI rule when vector elements are subdivided into sub-weights.  <a href="compress__utils_8c.html#a28de42583a3739fb7dde3653f15f68d2">More...</a><br /></td></tr>
<tr class="separator:a28de42583a3739fb7dde3653f15f68d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d18dd42256fc88dc0fa1921e3918517"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8c.html#a1d18dd42256fc88dc0fa1921e3918517">sys_comp</a> (double *vec_vals, size_t vec_len, double *loc_norms, unsigned int n_samp, int *keep_exact, double rand_num)</td></tr>
<tr class="memdesc:a1d18dd42256fc88dc0fa1921e3918517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Systematic resampling of vector elements.  <a href="compress__utils_8c.html#a1d18dd42256fc88dc0fa1921e3918517">More...</a><br /></td></tr>
<tr class="separator:a1d18dd42256fc88dc0fa1921e3918517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e5ff484f0f1af4dce9091452ba37fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8c.html#ab2e5ff484f0f1af4dce9091452ba37fb">adjust_shift</a> (double *shift, double one_norm, double *last_norm, double target_norm, double damp_factor)</td></tr>
<tr class="memdesc:ab2e5ff484f0f1af4dce9091452ba37fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust energy shift to maintain one-norm of solution vector in DMC simulation.  <a href="compress__utils_8c.html#ab2e5ff484f0f1af4dce9091452ba37fb">More...</a><br /></td></tr>
<tr class="separator:ab2e5ff484f0f1af4dce9091452ba37fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b4d82d2869bc857b57873b006cad85"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8c.html#ac8b4d82d2869bc857b57873b006cad85">sys_sub</a> (double *values, unsigned int *n_div, size_t n_sub, double(*sub_weights)[n_sub], int(*keep_idx)[n_sub], size_t count, unsigned int n_samp, double *wt_remain, double *loc_norms, double rand_num, double *new_vals, size_t(*new_idx)[2])</td></tr>
<tr class="memdesc:ac8b4d82d2869bc857b57873b006cad85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform systematic resampling on a vector with subdivided elements.  <a href="compress__utils_8c.html#ac8b4d82d2869bc857b57873b006cad85">More...</a><br /></td></tr>
<tr class="separator:ac8b4d82d2869bc857b57873b006cad85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac5b09f2156ac7fcfeebcfa93fd5d62"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="compress__utils_8c.html#acac5b09f2156ac7fcfeebcfa93fd5d62">comp_sub</a> (double *values, size_t count, unsigned int *n_div, size_t n_sub, double(*sub_weights)[n_sub], int(*keep_idx)[n_sub], unsigned int n_samp, double *wt_remain, double rand_num, double *new_vals, size_t(*new_idx)[2])</td></tr>
<tr class="memdesc:acac5b09f2156ac7fcfeebcfa93fd5d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform systematic compression with exact preservation on a vector whose elements are divided into sub-weights.  <a href="compress__utils_8c.html#acac5b09f2156ac7fcfeebcfa93fd5d62">More...</a><br /></td></tr>
<tr class="separator:acac5b09f2156ac7fcfeebcfa93fd5d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utilities for compressing vectors stochastically using the FRI framework. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ab2e5ff484f0f1af4dce9091452ba37fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e5ff484f0f1af4dce9091452ba37fb">&#9670;&nbsp;</a></span>adjust_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void adjust_shift </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>one_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>last_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>damp_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust energy shift to maintain one-norm of solution vector in DMC simulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">shift</td><td>Pointer to energy shift; updated upon return </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">one_norm</td><td>Current one-norm of solution vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">last_norm</td><td>Ptr to previous one-norm of solution vector, or 0 if vector norm is not yet being updated. Upon return, set to <code>one_norm</code> if one_norm &gt; target_norm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_norm</td><td>One-norm above which the energy shift should be adjusted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">damp_factor</td><td>Factor by which the shift calculated based on the change in one-norm is damped (or amplified) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acac5b09f2156ac7fcfeebcfa93fd5d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac5b09f2156ac7fcfeebcfa93fd5d62">&#9670;&nbsp;</a></span>comp_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t comp_sub </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>n_div</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)&#160;</td>
          <td class="paramname"><em>sub_weights</em>[n_sub], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)&#160;</td>
          <td class="paramname"><em>keep_idx</em>[n_sub], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wt_remain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rand_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>new_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t(*)&#160;</td>
          <td class="paramname"><em>new_idx</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform systematic compression with exact preservation on a vector whose elements are divided into sub-weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Magnitudes of elements of original vector on which to perform compression (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of vector to compress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_div</td><td>Number of uniform intervals into which each element is divided. If =0, this element is divided nonuniformly according to sub_wts at this position (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_sub</td><td>Length of 2nd dimension of <code>sub_wts</code> and <code>keep_idx</code> arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_weights</td><td>2-d array of sub-weights for vector elements divided nonuniformly; each nonzero row must sum to 1. Elements in rows corresponding to nonzero elements of n_div are undefined. (dimensions <code>count</code> * <code>n_sub</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_idx</td><td>Scratch array used to identify elements to preserve exactly. Must be 0 upon input (dimensions <code>count</code> * <code>n_sub</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_samp</td><td>Desired number of nonzero elements in compressed vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wt_remain</td><td>Scratch array used for compression (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rand_num</td><td>A random number chosen uniformly on [0, 1). Only the argument from the 0th MPI process is used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_vals</td><td>Magnitudes of elements in compressed vector, including elements preserved exactly </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_idx</td><td>Indices of elements of the compressed vector in the original (input) vector. The 0th column gives the index in the values array, and the 1st gives the index of the subdivided element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the compressed array (at most n_samp) </dd></dl>

</div>
</div>
<a id="a28de42583a3739fb7dde3653f15f68d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28de42583a3739fb7dde3653f15f68d2">&#9670;&nbsp;</a></span>find_keep_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double find_keep_sub </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>n_div</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)&#160;</td>
          <td class="paramname"><em>sub_weights</em>[n_sub], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)&#160;</td>
          <td class="paramname"><em>keep_idx</em>[n_sub], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wt_remain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify elements to preserve exactly according to the FRI rule when vector elements are subdivided into sub-weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Magnitudes of elements of vector to be compressed (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_div</td><td>Number of uniform intervals into which each element is divided. If =0, this element is divided nonuniformly according to sub_wts at this position (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_sub</td><td>Length of 2nd dimension of <code>sub_wts</code> and <code>keep_idx</code> arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_weights</td><td>2-d array of sub-weights for vector elements divided nonuniformly; each nonzero row must sum to 1. Elements in rows corresponding to nonzero elements of n_div are undefined. (dimensions <code>count</code> x <code>n_sub</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">keep_idx</td><td>2-d array that contains 1's at all positions to be preserved exactly. Elements must be zeroed before calling. If vector is divided uniformly, only the element in the 0th column is set to 1 (dimensions <code>count</code> * <code>n_sub</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of vector to compress </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">n_samp</td><td>Pointer to desired number of nonzero elements after compression; upon return, points to remaining number available for systematic resampling </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">wt_remain</td><td>Sum of magnitudes of sub-elements not preserved exactly at each position (length <code>count</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of magnitudes of elements on this local MPI process that are not preserved exactly </dd></dl>

</div>
</div>
<a id="a8a1355ac3c7b200e2a3e7d9728783ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1355ac3c7b200e2a3e7d9728783ff6">&#9670;&nbsp;</a></span>find_preserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double find_preserve </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>srt_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>keep_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>global_norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify the greatest-magnitude elements of a vector. </p>
<p>The greatest-magnitude elements of the vector are identified according to the rule in the FRI paper and preserved exactly in the compression</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td><a class="el" href="struct_vector.html">Vector</a> of elements (can be + or -); not modified in this subroutine (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srt_idx</td><td>An array of indices that will be used to build the heap, must be initialized with integers from 0 to count - 1 in any order (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">keep_idx</td><td>Contains 1's at each position of values designated to be preserved exactly. Upon input, all elements must be 0 (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements in the vector being compressed </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">n_samp</td><td>Pointer to desired number of nonzero elements after compression. Upon return, points to remaining number available for systematic resampling </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">global_norm</td><td>The norm of the whole vector, including preserved elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of magnitudes of elements that are not preserved exactly </dd></dl>

</div>
</div>
<a id="a1e6d1037941be464363981d4b3e4fe52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6d1037941be464363981d4b3e4fe52">&#9670;&nbsp;</a></span>round_binomially()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int round_binomially </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmt__struct.html">mt_struct</a> *&#160;</td>
          <td class="paramname"><em>mt_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round a non-integral number binomially. </p>
<p>Given a non-integral input p and a positive-integral input n, the result r of this operation is distributed according to: </p><p class="formulaDsp">
\[ r \sim \text{binomial}(n, p - \text{floor}(p)) + \text{floor}(p) * n \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The non-integral parameter p of the rounding operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The positive integral parameter n of the rounding oper. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mt_ptr</td><td>Address to MT state object to use for RN generation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer result r of the operation </dd></dl>

</div>
</div>
<a id="aefbd13c575f5d56f4dbf0a510dbad157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbd13c575f5d56f4dbf0a510dbad157">&#9670;&nbsp;</a></span>seed_sys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double seed_sys </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_samp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set-up for performing systematic compression across many MPI processes. </p>
<p>Calculates the position of the first random sample on each MPI process</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">norms</td><td>Array of one-norms of the portions of the vector stored on each processor (length <code>n_samp</code>) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rn</td><td>Pointer to a random number generated on [0,1). Upon return, will be set to the position of the random sample (the "X" in the paper) within this portion of the vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_samp</td><td>Desired number of elements to select randomly </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of the one-norms of the portions of the vector stored on MPI processes with ranks less than the current one </dd></dl>

</div>
</div>
<a id="aaa514ed6284e1c7ae31e0907621aa3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa514ed6284e1c7ae31e0907621aa3da">&#9670;&nbsp;</a></span>sum_mpi_d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sum_mpi_d </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_procs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum a variable across all MPI processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local</td><td>local value to be summed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">global</td><td>pointer to where result should be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my_rank</td><td>Rank of the local processor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_procs</td><td>Total number of MPI processes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac033a06f40f9f0b12a18b5002a249b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac033a06f40f9f0b12a18b5002a249b18">&#9670;&nbsp;</a></span>sum_mpi_i()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sum_mpi_i </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_procs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum a variable across all MPI processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local</td><td>local value to be summed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">global</td><td>pointer to where result should be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my_rank</td><td>Rank of the local processor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_procs</td><td>Total number of MPI processes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d18dd42256fc88dc0fa1921e3918517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d18dd42256fc88dc0fa1921e3918517">&#9670;&nbsp;</a></span>sys_comp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_comp </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vec_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vec_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>loc_norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>keep_exact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rand_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Systematic resampling of vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vec_vals</td><td>Elements in the vector (can be negative) before and after compression (length <code>vec_len</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vec_len</td><td>Number of elements in the vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">loc_norms</td><td>Sum of magnitudes of elements on each MPI process before and after compression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_samp</td><td>Number of samples in systematic resampling </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keep_exact</td><td>Array indicating elements to be preserved exactly in compression; upon return, 1's indicate elements zeroed in the compression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rand_num</td><td>A random number chosen uniformly on [0, 1). Only the argument from the 0th MPI process is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8b4d82d2869bc857b57873b006cad85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b4d82d2869bc857b57873b006cad85">&#9670;&nbsp;</a></span>sys_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sys_sub </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>n_div</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)&#160;</td>
          <td class="paramname"><em>sub_weights</em>[n_sub], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)&#160;</td>
          <td class="paramname"><em>keep_idx</em>[n_sub], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_samp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wt_remain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>loc_norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rand_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>new_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t(*)&#160;</td>
          <td class="paramname"><em>new_idx</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform systematic resampling on a vector with subdivided elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Magnitudes of elements of original vector to be compressed, potentially with some elements preserved exactly (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_div</td><td>Number of uniform intervals into which each element is divided. If =0, this element is divided nonuniformly according to sub_wts at this position (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_sub</td><td>Length of 2nd dimension of <code>sub_wts</code> and <code>keep_idx</code> arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_weights</td><td>2-d array of sub-weights for vector elements divided nonuniformly; each nonzero row must sum to 1. Elements in rows corresponding to nonzero elements of n_div are undefined. (dimensions <code>count</code> * <code>n_sub</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_idx</td><td>2-d array that contains 1's at all positions to be preserved exactly. (dimensions <code>count</code> * <code>n_sub</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Length of vector to compress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_samp</td><td>Number of elements to select in systematic resampling </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wt_remain</td><td>Sum of magnitudes of sub-elements not preserved exactly at each position (length <code>count</code>) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">loc_norms</td><td>Sum of magnitudes of elements on each MPI process not preserved exactly </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rand_num</td><td>A random number chosen uniformly on [0, 1). Only the argument from the 0th MPI process is used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_vals</td><td>Magnitudes of elements in compressed vector, including elements preserved exactly </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_idx</td><td>Indices of elements of the compressed vector in the original (input) vector. The 0th column gives the index in the values array, and the 1st gives the index of the subdivided element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in compressed vector </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
